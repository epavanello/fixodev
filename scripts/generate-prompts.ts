import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';
import chokidar from 'chokidar';

const extractPlaceholders = (templateContent: string): string[] => {
  const regex = /{{\s*(\w+)\s*}}/g;
  const placeholders = new Set<string>();
  let match;
  while ((match = regex.exec(templateContent))) {
    placeholders.add(match[1]);
  }
  return Array.from(placeholders);
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROMPTS_DIR = path.resolve(__dirname, '../src/llm/prompts');
const OUTPUT_PROMPTS_FILE = path.resolve(PROMPTS_DIR, 'prompts.ts');
const PROMPT_UTILS_PATH = './prompt-utils'; // Relative path for imports in generated file

/**
 * Converts a kebab-case or snake_case filename to a PascalCase string.
 */
function filenameToPascalCase(filename: string): string {
  return filename
    .replace(/\.(md|txt)$/i, '') // Remove extension
    .split(/[-_]/)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())
    .join('');
}

async function generateFunctionsForSinglePromptFile(
  templateFilePath: string,
): Promise<{ typeDef: string; functionDef: string } | null> {
  try {
    const templateFilename = path.basename(templateFilePath);
    const templateContent = await fs.readFile(templateFilePath, 'utf-8');
    const placeholders = extractPlaceholders(templateContent);

    const baseName = filenameToPascalCase(templateFilename);
    const functionName = `generate${baseName}Prompt`;
    const argsTypeName = `${baseName}Args`;

    let typeDef = `export type ${argsTypeName} = {\n`;
    if (placeholders.length === 0) {
      typeDef += '  // No placeholders, this will be an empty object\n';
      typeDef += '  [key: string]: never;\n'; // Or Record<string, never>
    } else {
      placeholders.forEach(p => {
        typeDef += `  readonly ${p}: string;\n`;
      });
    }
    typeDef += '};\n';

    const relativeTemplatePath = path.relative(PROMPTS_DIR, templateFilePath).replace(/\\/g, '/');

    let functionDef = `\n/**\n * Generates the '${templateFilename}' prompt.\n * Template path: ${relativeTemplatePath}\n */\n`;
    functionDef += `export async function ${functionName}(\n  args: ${argsTypeName}\n): Promise<string> {\n`;
    functionDef += `  const templatePath = path.resolve(__dirname, '${relativeTemplatePath}');\n`;
    functionDef += `  const templateContent = await fs.readFile(templatePath, 'utf-8');\n`;
    functionDef += `  return render(templateContent, args as Record<string, string>);\n`;
    functionDef += '}\n';

    return { typeDef, functionDef };
  } catch (error) {
    console.error(`Error processing ${templateFilePath}:`, error);
    return null;
  }
}

async function regenerateAllPromptsFile(): Promise<void> {
  console.log('Scanning for prompt templates in:', PROMPTS_DIR);
  try {
    const files = await fs.readdir(PROMPTS_DIR);
    // Exclude the output file itself and any non-markdown files
    const mdFiles = files.filter(
      file => file.endsWith('.md') && path.join(PROMPTS_DIR, file) !== OUTPUT_PROMPTS_FILE,
    );

    let outputContent = `// Auto-generated by scripts/generate-prompts.ts
// Do not edit this file manually.

import * as fs from 'fs/promises';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { render } from '${PROMPT_UTILS_PATH}';

// It is expected that this generated file (prompts.ts) is in the same directory 
// as the .md template files it references and prompt-utils.ts.
// If not, __dirname logic might need adjustment or paths made absolute from project root.
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename); 

// --- Argument Types ---
`;

    const functionDefinitions: string[] = [];

    if (mdFiles.length === 0) {
      console.log('No .md prompt templates found.');
      outputContent += '\n// No prompt templates found to generate functions for.\n';
    } else {
      for (const mdFile of mdFiles) {
        const filePath = path.join(PROMPTS_DIR, mdFile);
        const result = await generateFunctionsForSinglePromptFile(filePath);
        if (result) {
          outputContent += result.typeDef + '\n';
          functionDefinitions.push(result.functionDef);
        }
      }
    }

    outputContent += '\n// --- Prompt Generation Functions ---\n';
    outputContent += functionDefinitions.join('\n');

    await fs.writeFile(OUTPUT_PROMPTS_FILE, outputContent);
    console.log(
      `Successfully generated ${mdFiles.length} prompt function(s) into: ${OUTPUT_PROMPTS_FILE}`,
    );
  } catch (error) {
    console.error('Error regenerating prompts file:', error);
    try {
      await fs.writeFile(
        OUTPUT_PROMPTS_FILE,
        `// Error during generation: ${error instanceof Error ? error.message : String(error)}\n`,
      );
    } catch (writeError) {
      console.error('Failed to write error state to output file:', writeError);
    }
  }
}

async function main() {
  await regenerateAllPromptsFile(); // Initial generation

  console.log(
    `Watching for changes in .md files in ${PROMPTS_DIR} (excluding ${path.basename(OUTPUT_PROMPTS_FILE)})...`,
  );

  const watcher = chokidar.watch(path.join(PROMPTS_DIR, '**/*.md'), {
    ignored: [
      /(^|[/\\])\../, // ignore dotfiles
      OUTPUT_PROMPTS_FILE, // ignore the output file itself
    ],
    persistent: true,
    ignoreInitial: true,
  });

  const handleChange = async (filePath: string) => {
    // Check if the changed file is the output file itself to prevent loops, though `ignored` should handle this.
    if (path.resolve(filePath) === path.resolve(OUTPUT_PROMPTS_FILE)) return;
    console.log(`File ${filePath} has been changed/added/removed`);
    await regenerateAllPromptsFile();
  };

  watcher
    .on('add', handleChange)
    .on('change', handleChange)
    .on('unlink', handleChange)
    .on('error', error => console.error(`Watcher error: ${error}`));

  process.on('SIGINT', () => {
    console.log('Stopping watcher...');
    watcher.close();
    process.exit(0);
  });
}

main().catch(console.error);
